---
> **ARTS-week-30**
> 2023-07-22 20:37
---


## ARTS-2019 左耳听风社群活动--每周完成一个 ARTS
1.Algorithm： 每周至少做一个 leetcode 的算法题
2.Review: 阅读并点评至少一篇英文技术文章
3.Tip: 学习至少一个技术技巧
4.Share: 分享一篇有观点和思考的技术文章

### 1.Algorithm:

- [623. 在二叉树中增加一行](https://leetcode.cn/submissions/detail/447328767/)  
    + 思路：递归
- [874. 模拟行走机器人](https://leetcode.cn/submissions/detail/448195685/)  
    + 思路：哈希
- [918. 环形子数组的最大和](https://leetcode.cn/submissions/detail/448519364/)  
    + 思路：双指针

### 2.Review:

[微管道：使用微型应用程序分析大数据](https://underthehood.meltwater.com/blog/2019/07/12/micro-pipelines-analyzing-big-data-with-tiny-apps/)

我们在Meltwater的一个团队最近遇到了一个问题，需要将相对简单的任务应用于大量数据。为了解决这个问题，我们尝试了一种我们称之为微管道的模式，微管道是一系列微服务，它们协同工作以创建高效的容错系统。

这篇文章提供了一个我们如何设计和构建这样一个微管道的例子。

#### 挑战

我们的团队的任务是从几个不同的来源获取数据，并在其中的项目中查找关系。该系统需要监控网站流量数据，每天约有 6 亿个事件，识别我们感兴趣的数据点，将它们与来自几个不同数据源的现有系统中的内容进行匹配，最后执行一些分析任务并存储结果。对于每个任务，查找这些项目、匹配它们和执行分析的逻辑相对简单，但是数据量会带来各种挑战。

在最初的设计讨论中，我们有一些看似可行的想法，但我们注意到在构建应用程序来处理如此大量的数据时存在两个关键缺陷。

- 1.从一个源接收数据并在其他源中查找相关匹配项的时间在每个请求中花费几秒钟。这将要求我们每天 24 小时同时运行大约 21，000 个进程。从监控和成本的角度来看，这对我们来说似乎是一场噩梦。

- 2.过程中的任何故障都会导致数据丢失和资源浪费。如果流程中的某个项目在几秒钟内失败，则必须重新开始。假设即使是适度的故障率也会使我们之前的 21，000 个进程数量跃升得更高。
我们开始寻找各种工具来管理大量类似的流程，如容器编排和自动扩展 EC2 实例。

我们还考虑了AWS Lambda函数。Lambas 最初被忽略了，因为我们认为由于一些更复杂的进程的执行时间很长，它们会超时，但我们对触发和连接 AWS Lambda 函数的各种方法很感兴趣。考虑到这一点，我们重新检查了原始设计，并将过滤过程和匹配算法的每个部分分解为一个离散的步骤。这导致了如下所示的巨大流程图。

[](./images/ARTS-week-30-1.png)

我们决定将大型应用程序分解为一系列微服务 （Lambda），这些微服务在管道中执行小步骤，并使用 SQS、Dynamo 或 SNS 来触发流程中的下一步。

在弄清楚如何以最佳方式将所有这些服务连接在一起时，我们考虑了流程中每个步骤的以下两个问题。

#### 1. 此步骤是否会过滤或减少传递到下一步的数据量？

我们的流程有一些简单的步骤，根据用户偏好或数据源过滤数据，以及一些需要进行API或数据库调用的更复杂的步骤。为了使系统尽可能高效，我们希望确保减少数据总量的步骤在管道的早期进行。我们还试图使早期过滤 Lambda 尽可能简单。例如，我们没有构建一个筛选 4 个数据属性的服务，而是构建了 4 个小服务，每个服务负责一个筛选器。早期过滤的一些良好候选示例包括从没有关注者的帐户中删除推文，或者从我们的用户未监控的国家/地区剥离分析数据。

我们的目标是尽可能少地花在不有价值的数据上，并确保以后更复杂的流程不会因机器人的推文或北饺子王国的分析而陷入困境（几年前，北饺子王国是一个失败的国家，给我们带来了一个非常棘手的错误）。

#### 2. 此步骤的最终结果是有价值的数据还是另一个步骤的触发器？

在管道中将这些进程链接在一起时，我们需要在它们之间传递数据。AWS 为数据存储、队列、通知和文件存储提供了不同的工具，因此我们需要准确缩小每个步骤接受作为输入和作为输出生成的内容。

我们在流程之间传递数据和事件的两个主要关注点是效率和容错。SNS和SQS等系统提供了在进程之间传递事件和少量数据的非常有效的方法，但不打算长期存储数据，也不理想地用于故障恢复。Dynamo是存储较大数据项的绝佳工具，与 SQS 不同，它提供永久数据存储，但比将数据作为 Lambda 触发器的一部分传入要慢。

我们查看了流程中的每个步骤，并在输出单个值（如数据库中项的 ID、URL 或其他一些本身几乎没有调试或恢复值的数据项）时使用 SQS 作为输出目标。然后，我们使用 Dynamo 存储输出的数据，这些输出可以是较大的对象，或者是在发生故障时可以轻松重新启动进程的点。

##### 组织和部署微管道

在此过程结束时，我们有一个系统，可以有效地处理我们的预计负载并从各种系统故障中恢复。我们还有一个易于更新的系统，因为每个步骤都可以独立测试和更换。不幸的是，我们还面临着部署和更新十几个 Lambda、几个 dynamo 表、几个 SQS 队列和两个 API 网关的任务。

我们需要一种方法在不同的环境中同时部署整个系统，并且我们希望监控基础架构的状态。将管道的所有源代码存储在单个 GitHub 存储库中，使我们能够通过 CI 工具轻松地将内容部署在一起，并更轻松地在进程之间共享代码。CloudFormation是管理基础架构的绝佳解决方案，但将所有内容都放在同一个存储库中会导致数千行长的巨大 YAML 配置文件。

我们通过为每个 Lambda 函数创建一个单独的配置文件来解决此问题，该文件包含任何直接依赖项和馈送到其中的任何事件源。例如，使用来自 SQS 的消息的 Lambda 会将该 SQS 队列的定义存储在其配置文件中。在我们的构建过程中，我们的 CI 工具将所有 YAML 文件连接成一个配置文件，使用mustache替换特定于每个环境的值，然后通过 CloudFormation 部署整个文件。

这使我们能够轻松编辑 Lambda 函数;将该 Lambda 的配置和输入源保存在与源代码相同的文件夹中。我们目前正在研究进一步改进此过程的方法，例如将每个步骤设置为单独的节点模块，并为它们创建一个系统，以便向父应用公开其基础结构配置要求。我们的目标是使这些步骤中的每一个都成为一个可移植、可配置的单元，使我们能够在需要时快速组合新的管道。

### 结果

几个月来，我们一直在使用这种微管道模式运行几个不同的系统。在能够对事件做出反应方面，我们特别喜欢微型管道的行为，如以下两个示例所示：

- 1.早期，我们与合作伙伴发生了网络故障，必须在一天内处理 3 天的数据。我们提高了管道中前两个 Lambda 函数的自动扩展阈值，并在不到 24 小时内恢复了工作。我们不必重新部署，也不必担心扩展整个管道的成本，只需担心承受额外负载的部分。

- 2.在类似的情况下，我们调用的其中一个 API 发生了重大更改，导致备份。我们对 once 服务进行了一个小的更改，并且能够在管道开始时不启动所有内容即可恢复。

这种将大型应用程序分解为一系列事件驱动的微服务的模式为我们的团队提供了很好的帮助。这些系统的灵活性和容错能力非常好，由于可靠的基础设施即代码工具，我们最初对管理复杂性的担忧基本上是无痛的。随着我们替换遗留代码并构建新功能，我们可能会更多地利用这种模式，我们相信它将使我们能够在构建可重用微服务库时加速功能。

如果使用过类似的模式或对如何使其更好有想法，请在下面发表评论。


### 3.Tip:

#### 修改 Android WebView 的字体大小

```java
WebView webView = findViewById(R.id.wv_web);
webView.getSettings().setTextZoom(100); // 通过百分比来设置文字的大小，默认值是100。
```

#### HTML代码转义: 以&lt;div开头，而不是HTML代码通用的<div 只需将带有&lt;的HTML代码调用以下方法，再进行加载，即可正常显示。
```java
private String translation(String content) {
    String replace = content.replace("&lt;", "<");
    String replace1 = replace.replace("&gt;", ">");
    String replace2 = replace1.replace("&amp;", "&");
    String replace3 = replace2.replace("&quot;", "\"");
    return replace3.replace("&copy;", "©");
}
```

这种方法使用起来相对于第一种方法会更灵活一些。 

3.第三种方法：

```java
getDialog().getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE,
        WindowManager.LayoutParams.FLAG_SECURE);
```

### 4.Share:

[P12,JKS,CER,RFX,PEM转换速记](https://www.cnblogs.com/cherrychen-cakuta/p/8028020.html)

[npm删除依赖项_npm依赖项和devDependencies](https://blog.csdn.net/cuk0051/article/details/108342952)

[从Springboot探索spring到底从哪开始解析注解的](https://www.jianshu.com/p/b28cab955521)

[使用spring的MethodInterceptor实现aop功能的三种方式](https://blog.csdn.net/u013905744/article/details/91364736)