---
title: ARTS-week-5
date: 2019-09-28 16:29:48
tags:
---

## ARTS-2019 左耳听风社群活动--每周完成一个 ARTS
1.Algorithm： 每周至少做一个 leetcode 的算法题
2.Review: 阅读并点评至少一篇英文技术文章
3.Tip: 学习至少一个技术技巧
4.Share: 分享一篇有观点和思考的技术文章

### 1.Algorithm:

Longest Palindromic Substring：https://leetcode.com/submissions/detail/264961731/

### 2.Review:

Dapper：http://research.google.com/pubs/pub36356.html
大规模分布式系统的跟踪系统
作者：Benjamin H. Sigelman, Luiz Andr´e Barroso, Mike Burrows, Pat Stephenson, Manoj Plakal, Donald Beaver, Saul Jaspan, Chandan Shanbhag

#### 点评：

##### 背景:

现代的应用服务，往往是非常复杂的，如下的情况非常常见：
软件的模块有不同团队开发
整体由多种编程语言实现
牵扯到多种操作系统和硬件
关联不同数据中心的众多服务器
…
在这样的背景下，跟踪系统更加复杂，传统方式的跟踪系统往往是系统整体机能的一部分，往往侵入性过强，往往会产生由监控代码段引入的缺陷出现，同时由于监控间隔的设定调整也往往会对整体性能带来较大的负担，尤其是实时跟踪的场合下。

##### 为什么需要跟踪系统：
故障快速定位、恶性循环的形成、现状把握&决策支持

##### 启示1: 跟踪系统的需求
在 Dapper 的论文这样认为，有两个重要的需求需要予以满足：ubiquitous deployment 和 continuous monitoring 。而这两个需求是对跟踪系统的使用范围（不要有死角）和运行方式（不要停）做了规范。

##### 启示2: 跟踪系统的三大设计要点
dapper 在设计的时候考虑到了上述的背景，作为大规模集群的跟踪系统，需要满足如下三大设计要点：
低损耗（Low overhead）
应用级透明（Application-level transparency）
扩展性（Scalability）

##### 启示3: 跟踪系统的KPI
采样率：根据 google 的实践经验，采样率效率1/16时即能避免明显延迟，性能损耗在实验误差范围之内。
损耗：跟踪系统自身的性能影响对于系统应该是能够忽略不计的，pinpoint 控制在3%之内。
实效性：跟踪数据产生之后，分析的速度需要及时快速，理想状况数据在一分钟之内能够统计出来，以便对于生产环境的异常状况作出快速反应。

##### 启示4: 可以关闭的跟踪系统
考虑到性能和安全的因素，生产环境的跟踪系统应该也可以关闭。

##### 启示5: 准确定位延迟问题
google 通过使用 dapper 提供了这种情况下的急需数据，其实践有如下经验：
1. 问题往往来源于一些意想不到的服务之间的交互，问题的纠正往往比较容易，而在 dapper 引入之前发现较为困难
2. 简化跟踪的接口，使用唯一的追踪ID，便于集成和检测

##### 启示6: 跟踪系统给开发团队能带来什么
根据 google 的实践，跟踪系统能够帮助开发团队快速定位需要优化的应用，以及确定关键路径上非必要的串行请求。

##### 启示7: 安全和隐私的考虑
跟踪系统能够记录一定的信息用于解释系统异常的原因，然后，这些数据可能包含一些不应该透露的内部信息，而这些信息可能正在调试的工程师也无权访问。

##### 启示8: dapper系统的核心构成
dapper 是通过 trace tree 和 span 构建跟踪系统的。

span 名称：用于记录 span 的名称
spanid：用于记录 span的Id，一般用全局唯一的64位整数表示
父 spanid：父 span 的 spanid ，用于描述跟踪树结构
事件信息：cs/cr/sr/ss 四种事件类型，span 不同的事件类型对应不同的时间戳，根据这些时间戳，可计算出不同阶段的耗时信息。
annotation：一般，事件信息在 annotation 中存放，另外自定义的信息也可以与之关联

##### 启示9: 定位全局网络流量和使用率
Dapper 不是设计用来做链路级的监控的，但是在实践中发现，其比较适合去做集群之间活动性的应用及认为分析，显示集群之间最活跃的网络流量的应用级热点，与传统的的网络相关的工具相比，最重要的特点是 dapper 可以定位到应用程序级别的根本问题。

##### 启示10：dapper不太适合的场景
dapper 的模型的隐含前提是不同的子系统使用同一个被跟踪的请求所产生的连锁链式调用栈的情况。如果是多个追踪请求合并起来，而最终只使用其中的一个的情况则无法很好地对应。
dapper 可以找出性能瓶颈，但是并不一定能准确定位到根本原因，因为定位出很慢的结果往往是由其他请求造成的，而这则需要进一步的分析。
dapper 的设计主要是针对在线服务的系统，尤其是一个用户请求的系统行为，但是离线的情况下，则不能直接使用，需要一些人工的关联和干预行为。

### 3.Tip:

nginx 反向代理配置 url

在 nginx 中配置 proxy_pass 时，当在后面的url加上了/，相当于是绝对根路径，则 nginx 不会把 location 中匹配的路径部分代理走;
如果没有/，则会把匹配的路径部分也给代理走。下面四种场景分别用 http://192.168.1.6/proxy/index.html 进行访问。

场景一：会被代理到 http://127.0.0.1:8080/index.html
``` bash
location /proxy/ {
     proxy_pass http://127.0.0.1:8080/;
}
```

场景二：相对于场景一，最后少一个 /。会被代理到 http://127.0.0.1:8080/proxy/index.html
``` bash
location /proxy/ {
     proxy_pass http://127.0.0.1:8080;
}
```

场景三：会被代理到 http://127.0.0.1:8080/app/index.html
``` bash
location /proxy/ {
     proxy_pass http://127.0.0.1:8080/app/;
}
```

场景四：相对于场景三，最后少一个 /。会被代理到 http://127.0.0.1:8080/appindex.html
``` bash
location /proxy/ {
     proxy_pass http://127.0.0.1:8080/app;
}
```

### 4.Share:

Maven私服Nexus的搭建(https://www.jianshu.com/p/e4a3ab0298df)